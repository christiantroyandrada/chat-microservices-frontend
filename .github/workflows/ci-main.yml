name: ci - master
on:
  # Run this workflow when changes are pushed to the main branch
  # (post-PR merge / direct pushes to main)
  push:
    branches: [main, master]

jobs:
  build-and-sonar:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        # Pinned to specific commit SHA for supply-chain security
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Setup Node.js
        # Pinned to specific commit SHA for supply-chain security
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020
        with:
          node-version: '22'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install frontend deps
        working-directory: ./
        run: pnpm install

      - name: npm/pnpm audit (dependency vulnerability check)
        working-directory: ./
        run: |
          # Try pnpm audit first; fall back to npm audit for compatibility
          pnpm audit --audit-level=moderate || npm audit --audit-level=moderate || true

      - name: Lint (Prettier + ESLint)
        working-directory: ./
        run: pnpm run lint

      - name: TypeScript type check
        working-directory: ./
        run: pnpm exec tsc --noEmit

      - name: Svelte check
        working-directory: ./
        run: pnpm run check

      - name: Build FE (prepare + build)
        working-directory: ./
        run: |
          pnpm run prepare || true
          pnpm run build

      - name: Ensure Playwright browsers are installed
        working-directory: ./
        run: pnpm exec playwright install

      - name: Ensure coverage temp directory exists
        working-directory: ./
        run: mkdir -p coverage/.tmp

      - name: Run unit tests and generate coverage
        working-directory: ./
        run: pnpm run coverage:unit
        timeout-minutes: 15

      - name: Check Sonar secrets/vars
        working-directory: ./
        run: |
          if [ -z "$SONAR_TOKEN" ]; then
            echo "::error::SONAR_TOKEN is not set. Add it under Settings ‚Üí Secrets and variables ‚Üí Actions.";
            exit 1;
          fi
          if [ -z "$SONAR_ORGANIZATION_SECRET" ] && [ -z "$SONAR_ORGANIZATION_VAR" ]; then
            echo "::error::SONAR_ORGANIZATION is not set as a secret or variable. Add it under Settings ‚Üí Secrets and variables ‚Üí Actions.";
            exit 1;
          fi
          echo "Sonar secrets/vars present. Proceeding..."
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_ORGANIZATION_SECRET: ${{ secrets.SONAR_ORGANIZATION }}
          SONAR_ORGANIZATION_VAR: ${{ vars.SONAR_ORGANIZATION }}

      - name: SonarCloud Scan
        # Pinned to specific commit SHA for supply-chain security
        uses: SonarSource/sonarqube-scan-action@fd88b7d7ccbaefd23d8f36f73b59db7a3d246602
        with:
          args: >
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.exclusions=tests/**,test/**,__mocks__/**,mocks/**
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}

  # Deploy to VPS (only runs on main branch after build and tests pass)
  deploy:
    name: Deploy Frontend to VPS
    needs: build-and-sonar
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    environment: production
    concurrency:
      group: production-frontend-deployment
      cancel-in-progress: false

    steps:
      - name: Fetch secrets from Infisical
        id: infisical
        uses: Infisical/secrets-action@v1.0.7
        with:
          method: universal
          client-id: ${{ secrets.INFISCAL_CLIENT_ID }}
          client-secret: ${{ secrets.INFISCAL_CLIENT_SECRET }}
          project-slug: ${{ secrets.INFISCAL_PROJECT_SLUG }}
          env-slug: prod
          secret-path: /

      - name: Deploy Frontend via SSH
        uses: appleboy/ssh-action@029f5b4aeeeb58fdfe1410a5d17f967dacf36262
        env:
          # Infisical secrets-action sets secrets as ENV VARS (not outputs)
          # Only database credentials needed for docker compose ps/config commands
          ADMIN_USERNAME: ${{ env.ADMIN_USERNAME }}
          ADMIN_PASSWORD: ${{ env.ADMIN_PASSWORD }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: ${{ secrets.VPS_PORT || '22' }}
          command_timeout: 20m
          envs: ADMIN_USERNAME,ADMIN_PASSWORD
          script: |
            set -euo pipefail
            export DEPLOY_PATH="${{ secrets.DEPLOY_PATH || '/opt/chat-app' }}"

            # Export minimal environment variables for docker compose commands
            # (Only needed because postgres service references these in compose file)
            export ADMIN_USERNAME
            export ADMIN_PASSWORD

            echo "üöÄ Starting frontend deployment..."

            # Ensure DEPLOY_PATH is writable; fall back to $HOME if needed
            if ! mkdir -p "$DEPLOY_PATH" 2>/dev/null; then
              echo "‚ö†Ô∏è Cannot create $DEPLOY_PATH (permission denied). Falling back to home directory"
              FALLBACK="$HOME/chat-app"
              mkdir -p "$FALLBACK"
              export DEPLOY_PATH="$FALLBACK"
              echo "‚û°Ô∏è Using fallback DEPLOY_PATH=$DEPLOY_PATH"
            fi

            # Ensure frontend repo directory exists; clone if missing
            if [ -d "$DEPLOY_PATH/chat-microservices-frontend" ]; then
              echo "‚û°Ô∏è Found existing $DEPLOY_PATH/chat-microservices-frontend ‚Äî updating"
              cd "$DEPLOY_PATH/chat-microservices-frontend"
              if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
                # Detect current branch (master or main)
                CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "master")
                git fetch origin --prune || true
                git reset --hard origin/$CURRENT_BRANCH || git reset --hard origin/master || true
              else
                echo "‚ö†Ô∏è Directory exists but is not a git repo ‚Äî removing and re-cloning"
                cd "$DEPLOY_PATH"
                rm -rf chat-microservices-frontend
              fi
            fi

            if [ ! -d "$DEPLOY_PATH/chat-microservices-frontend" ]; then
              echo "‚û°Ô∏è Directory not found ‚Äî attempting to clone frontend repository"
              mkdir -p "$DEPLOY_PATH"
              cd "$DEPLOY_PATH"
              REPO_URL="https://github.com/${{ github.repository }}.git"
              if git ls-remote --exit-code "$REPO_URL" >/dev/null 2>&1; then
                # Frontend repo uses 'master' branch
                git clone --depth 1 --branch master "$REPO_URL" chat-microservices-frontend || {
                  echo "‚ö†Ô∏è git clone failed for frontend repo; creating empty folder"
                  mkdir -p chat-microservices-frontend
                }
                cd chat-microservices-frontend || true
              else
                echo "‚ö†Ô∏è Cannot access $REPO_URL (permissions or network). Creating empty directory and continuing"
                mkdir -p chat-microservices-frontend
                cd chat-microservices-frontend
              fi
            fi

            # Ensure main microservices (backend) directory exists (where docker-compose files live)
            if [ ! -d "$DEPLOY_PATH/chat-microservices" ]; then
              echo "‚ö†Ô∏è $DEPLOY_PATH/chat-microservices not found ‚Äî attempting to clone backend repository"
              cd "$DEPLOY_PATH"
              BACKEND_REPO_URL="https://github.com/christiantroyandrada/chat-microservices.git"
              if git ls-remote --exit-code "$BACKEND_REPO_URL" >/dev/null 2>&1; then
                git clone --depth 1 --branch main "$BACKEND_REPO_URL" chat-microservices || {
                  echo "‚ö†Ô∏è Backend clone failed; creating empty folder"
                  mkdir -p chat-microservices
                }
              else
                echo "‚ö†Ô∏è Cannot access backend repo. Creating empty directory and continuing"
                mkdir -p chat-microservices
              fi
            fi

            cd "$DEPLOY_PATH/chat-microservices"

            # Pull latest backend repo to get updated docker-compose.prod.yml (with build args)
            echo "üîÑ Pulling latest backend repo for docker-compose files..."
            git fetch origin --prune || true
            git reset --hard origin/main || true

            # Note: Frontend .env file is NOT used for PUBLIC_* vars in SvelteKit
            # SvelteKit bakes PUBLIC_* env vars at BUILD TIME via Docker build args
            # The build args are defined in docker-compose.prod.yml

            # Check Docker permissions
            echo "üîç Checking Docker permissions..."
            if ! docker ps >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Docker permission denied. Attempting to add user to docker group..."
              # Check if user is in docker group
              if ! groups | grep -q docker; then
                echo "üí° User is not in docker group. To fix this on VPS, run:"
                echo "   sudo usermod -aG docker $USER && newgrp docker"
                echo "‚ö†Ô∏è Continuing anyway - docker commands may fail"
              fi
            else
              echo "‚úÖ Docker access confirmed"
            fi

            echo "üèóÔ∏è  Building frontend service (if defined in compose files)..."

            # Determine compose files to use
            COMPOSE_ARGS=()
            if [ -f docker-compose.yml ] && [ -f docker-compose.prod.yml ]; then
              COMPOSE_ARGS+=( -f docker-compose.yml -f docker-compose.prod.yml )
            elif [ -f docker-compose.yml ]; then
              COMPOSE_ARGS+=( -f docker-compose.yml )
            elif [ -f docker-compose.prod.yml ]; then
              COMPOSE_ARGS+=( -f docker-compose.prod.yml )
            else
              echo "‚ö†Ô∏è No docker-compose files found in $PWD ‚Äî skipping docker compose steps"
            fi

            # If compose files are present, try to build and bring up the frontend service
            # Frontend service uses 'frontend' profile - must include --profile frontend
            if [ ${#COMPOSE_ARGS[@]} -gt 0 ]; then
              # Check if 'frontend' service is defined (with profile)
              if docker compose --profile frontend "${COMPOSE_ARGS[@]}" config --services 2>/dev/null | grep -q '^frontend$'; then
                # Build frontend service with --no-cache to ensure PUBLIC_* URLs are baked in fresh
                # The build args (PUBLIC_API_URL, PUBLIC_WS_URL) are defined in docker-compose.prod.yml
                echo "üèóÔ∏è Building frontend service with production URLs..."
                docker compose --profile frontend "${COMPOSE_ARGS[@]}" build --no-cache frontend || {
                  echo "‚ö†Ô∏è Build step failed - checking build context"
                  docker compose --profile frontend "${COMPOSE_ARGS[@]}" config | grep -A 10 "frontend:" || true
                  echo "‚ö†Ô∏è Continuing anyway..."
                }
                
                # Start frontend service
                echo "üîÑ Starting frontend service..."
                docker compose --profile frontend "${COMPOSE_ARGS[@]}" up -d frontend || {
                  echo "‚ö†Ô∏è Up step failed"
                  docker compose --profile frontend "${COMPOSE_ARGS[@]}" logs frontend --tail=50 || true
                }

                echo "‚è≥ Waiting for frontend to be healthy..."
                sleep 15

                if docker compose --profile frontend "${COMPOSE_ARGS[@]}" ps frontend | grep -q "healthy\|running"; then
                  echo "‚úÖ Frontend is running"
                  echo "üîÑ Restarting nginx (if defined)"
                  if docker compose --profile frontend "${COMPOSE_ARGS[@]}" config --services 2>/dev/null | grep -q '^nginx$'; then
                    docker compose --profile frontend "${COMPOSE_ARGS[@]}" restart nginx || true
                    sleep 5
                  fi

                  if curl -f http://localhost:80/ > /dev/null 2>&1; then
                    echo "‚úÖ Frontend accessible through nginx"
                    echo "üéâ Frontend deployment successful!"
                  else
                    echo "‚ö†Ô∏è Frontend is running but not accessible through nginx"
                    echo "üìù Nginx logs:"
                    docker compose --profile frontend "${COMPOSE_ARGS[@]}" logs nginx --tail=20 || true
                    echo "üìù Frontend logs:"
                    docker compose --profile frontend "${COMPOSE_ARGS[@]}" logs frontend --tail=20 || true
                  fi
                else
                  echo "‚ùå Frontend deployment failed or service not healthy"
                  docker compose --profile frontend "${COMPOSE_ARGS[@]}" ps frontend || true
                  docker compose --profile frontend "${COMPOSE_ARGS[@]}" logs frontend --tail=50 || true
                  exit 1
                fi
              else
                echo "‚ö†Ô∏è 'frontend' service not defined in compose files ‚Äî skipping build/up steps"
              fi
            fi
